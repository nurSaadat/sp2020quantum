The quantum program in qiskit is essentially a QuantumCircuit executed on the 
backend or, alternatively, provider. The provider is an instance of a simulator 
or an API entry point to IBMQ quantum computer. The use of QuantumCircuits is 
explained in the tutorials for qiskit.

The QuantumCircuit object as it is described in tutorials can not be executed
directly, instead the compilation process is required. The compilation can 
either be explicitly called by using the compile() method or or it is called 
implicitely when you call execute() method. The compile() method outputs a Qobj
that is executable on provider.
Qobj is created using circuit_to_dag(QuantumCircuit) and wrapped up into 
QobjExperiment().. see qiskit\converters\circuits_to_qobj file.


The compile() method does several thing: it calls a transpiler.transpile(args) 
that matches the circuit to the coupling and does optimization passes. There is 
an option to omit the transpiler step if the pass_manager=PassManager() is given
as an argument to execute(...).

The abovementioned transpile() method is part of the transpiler package that 
"provides an extensible infrastructure of pluggable passes that allows 
flexibility in customizing the compilation pipeline through the creation and 
combination of new passes." (see the transpiler\Readme.md for more details on 
that).

In simple terms, the transpiler creates a DAG that represents a quantum circuit
and matches the coupling - specific architecture of a quantum computer, repre-
sented as list of tuples that describe physically connected qubits. 
initial layout to the compile object is what sets the mapping!



notes on parallel execution: it does the parallel_map anyway.



    q = QuantumRegister(device_qubits, 'q')
    for qreg in dag.qregs.values():
        for i in range(qreg.size):
            layout[(qreg.name, i)] = (q, int(best_sub[map_iter]))
            map_iter += 1